// Enhanced PDF Generator with Custom Templates and Watermarking
import React from 'react';
import { jsPDF } from 'jspdf';
import { memoizedFormatters } from './performanceOptimizer';

export class EnhancedPdfGenerator {
  constructor() {
    this.templates = {
      professional: this.professionalTemplate,
      forensic: this.forensicTemplate,
      minimal: this.minimalTemplate,
      detailed: this.detailedTemplate
    };
    
    this.watermarkOptions = {
      text: 'ProofPix',
      opacity: 0.1,
      fontSize: 48,
      angle: 45,
      color: [128, 128, 128]
    };
  }

  // Professional template for business use
  async professionalTemplate(pdf, data, options = {}) {
    const { margin } = this.getPageDimensions(pdf);
    let y = margin;

    // Header with company branding
    await this.addHeader(pdf, {
      title: 'Professional Image Analysis Report',
      subtitle: options.companyName || 'Generated by ProofPix',
      logo: options.logo,
      y: y
    });
    y += 60;

    // Executive summary
    if (options.includeSummary) {
      y = await this.addExecutiveSummary(pdf, data, y);
    }

    // Image preview with professional styling
    y = await this.addImageSection(pdf, data, y, {
      style: 'professional',
      showBorder: true,
      caption: true
    });

    // Metadata in structured format
    y = await this.addMetadataTable(pdf, data, y, {
      style: 'table',
      groupByCategory: true
    });

    // Technical specifications
    y = await this.addTechnicalSpecs(pdf, data, y);

    // Footer with certification info
    this.addFooter(pdf, {
      style: 'professional',
      certificationText: options.certificationText
    });

    return pdf;
  }

  // Forensic template for legal/investigative use
  async forensicTemplate(pdf, data, options = {}) {
    const { margin } = this.getPageDimensions(pdf);
    let y = margin;

    // Forensic header with case information
    await this.addForensicHeader(pdf, {
      caseNumber: options.caseNumber,
      investigator: options.investigator,
      date: new Date().toISOString(),
      y: y
    });
    y += 80;

    // Chain of custody section
    if (options.chainOfCustody) {
      y = await this.addChainOfCustody(pdf, options.chainOfCustody, y);
    }

    // Image integrity verification
    y = await this.addIntegritySection(pdf, data, y);

    // Complete metadata dump
    y = await this.addCompleteMetadata(pdf, data, y);

    // Hash verification
    if (options.includeHash) {
      y = await this.addHashVerification(pdf, data, y);
    }

    // Legal disclaimer
    this.addLegalDisclaimer(pdf);

    return pdf;
  }

  // Minimal template for quick reports
  async minimalTemplate(pdf, data, options = {}) {
    const { margin } = this.getPageDimensions(pdf);
    let y = margin;

    // Simple header
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(18);
    pdf.text('Image Metadata Report', margin, y);
    y += 20;

    // Basic image info
    y = await this.addBasicImageInfo(pdf, data, y);

    // Key metadata only
    y = await this.addKeyMetadata(pdf, data, y);

    // Simple footer
    this.addSimpleFooter(pdf);

    return pdf;
  }

  // Detailed template with comprehensive analysis
  async detailedTemplate(pdf, data, options = {}) {
    const { margin } = this.getPageDimensions(pdf);
    let y = margin;

    // Comprehensive header
    await this.addDetailedHeader(pdf, data, y);
    y += 70;

    // Image analysis section
    y = await this.addImageAnalysis(pdf, data, y);

    // Complete EXIF data
    y = await this.addCompleteExifData(pdf, data, y);

    // GPS analysis with map
    if (data.gpsData) {
      y = await this.addGpsAnalysis(pdf, data, y);
    }

    // Camera settings analysis
    y = await this.addCameraAnalysis(pdf, data, y);

    // Quality assessment
    y = await this.addQualityAssessment(pdf, data, y);

    return pdf;
  }

  // Add watermark to PDF
  addWatermark(pdf, options = {}) {
    const watermark = { ...this.watermarkOptions, ...options };
    const { pageWidth, pageHeight } = this.getPageDimensions(pdf);
    const totalPages = pdf.internal.getNumberOfPages();

    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      
      // Save current state
      pdf.saveGraphicsState();
      
      // Set watermark properties
      pdf.setGState(new pdf.GState({ opacity: watermark.opacity }));
      pdf.setTextColor(...watermark.color);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(watermark.fontSize);
      
      // Calculate position for center rotation
      const centerX = pageWidth / 2;
      const centerY = pageHeight / 2;
      
      // Add rotated watermark text
      pdf.text(watermark.text, centerX, centerY, {
        angle: watermark.angle,
        align: 'center'
      });
      
      // Restore state
      pdf.restoreGraphicsState();
    }
  }

  // Generate batch PDF with multiple images
  async generateBatchPdf(images, options = {}) {
    const pdf = new jsPDF(options.orientation || 'portrait');
    const template = options.template || 'professional';
    
    for (let i = 0; i < images.length; i++) {
      if (i > 0) pdf.addPage();
      
      const imageData = images[i];
      await this.templates[template].call(this, pdf, imageData, {
        ...options,
        pageNumber: i + 1,
        totalPages: images.length
      });
    }

    // Add watermark if requested
    if (options.watermark) {
      this.addWatermark(pdf, options.watermarkOptions);
    }

    // Add table of contents for batch reports
    if (options.includeTableOfContents && images.length > 1) {
      this.addTableOfContents(pdf, images);
    }

    return pdf;
  }

  // Helper methods
  getPageDimensions(pdf) {
    return {
      pageWidth: pdf.internal.pageSize.getWidth(),
      pageHeight: pdf.internal.pageSize.getHeight(),
      margin: 20
    };
  }

  async addHeader(pdf, options) {
    const { pageWidth, margin } = this.getPageDimensions(pdf);
    let y = options.y || margin;

    // Add logo if provided
    if (options.logo) {
      try {
        pdf.addImage(options.logo, 'PNG', margin, y, 40, 20);
      } catch (error) {
        console.warn('Could not add logo to PDF:', error);
      }
    }

    // Title
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(20);
    pdf.setTextColor(59, 130, 246);
    pdf.text(options.title, pageWidth / 2, y + 15, { align: 'center' });

    // Subtitle
    if (options.subtitle) {
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(12);
      pdf.setTextColor(107, 114, 128);
      pdf.text(options.subtitle, pageWidth / 2, y + 25, { align: 'center' });
    }

    // Date and time
    pdf.setFontSize(10);
    pdf.text(`Generated: ${new Date().toLocaleString()}`, pageWidth / 2, y + 35, { align: 'center' });

    return y + 45;
  }

  async addExecutiveSummary(pdf, data, y) {
    const { margin } = this.getPageDimensions(pdf);

    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(14);
    pdf.setTextColor(0, 0, 0);
    pdf.text('Executive Summary', margin, y);
    y += 10;

    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(10);
    pdf.setTextColor(55, 65, 81);

    const summary = this.generateSummary(data);
    const lines = pdf.splitTextToSize(summary, 170);
    
    lines.forEach(line => {
      pdf.text(line, margin, y);
      y += 5;
    });

    return y + 10;
  }

  generateSummary(data) {
    const { metadata } = data;
    let summary = `This report analyzes an image file "${metadata.fileName || 'Unknown'}" `;
    
    if (metadata.make && metadata.model) {
      summary += `captured with a ${metadata.make} ${metadata.model} camera. `;
    }
    
    if (metadata.dateTime) {
      summary += `The image was taken on ${memoizedFormatters.dateTime(metadata.dateTime)}. `;
    }
    
    if (metadata.gpsLatitude && metadata.gpsLongitude) {
      summary += `GPS coordinates indicate the location was recorded. `;
    }
    
    summary += `The file contains ${Object.keys(metadata).length} metadata fields with technical camera settings and image properties.`;
    
    return summary;
  }

  async addImageSection(pdf, data, y, options = {}) {
    const { pageWidth, margin } = this.getPageDimensions(pdf);

    // Section title
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(14);
    pdf.text('Image Preview', margin, y);
    y += 15;

    // Add image if available
    if (data.previewUrl) {
      try {
        const imgWidth = options.maxWidth || 120;
        const imgHeight = options.maxHeight || 90;
        const imgX = (pageWidth - imgWidth) / 2;

        if (options.showBorder) {
          pdf.setDrawColor(200, 200, 200);
          pdf.rect(imgX - 2, y - 2, imgWidth + 4, imgHeight + 4);
        }

        pdf.addImage(data.previewUrl, 'JPEG', imgX, y, imgWidth, imgHeight);
        y += imgHeight + 10;

        if (options.caption) {
          pdf.setFont('helvetica', 'italic');
          pdf.setFontSize(9);
          pdf.setTextColor(107, 114, 128);
          pdf.text(data.metadata.fileName || 'Image Preview', pageWidth / 2, y, { align: 'center' });
          y += 10;
        }
      } catch (error) {
        console.warn('Could not add image to PDF:', error);
        pdf.setFont('helvetica', 'italic');
        pdf.setFontSize(10);
        pdf.text('Image could not be embedded', margin, y);
        y += 15;
      }
    }

    return y;
  }

  async addMetadataTable(pdf, data, y, options = {}) {
    const { margin } = this.getPageDimensions(pdf);
    const { metadata } = data;

    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(14);
    pdf.text('Metadata Information', margin, y);
    y += 15;

    if (options.groupByCategory) {
      const categories = this.categorizeMetadata(metadata);
      
      for (const [category, fields] of Object.entries(categories)) {
        if (fields.length === 0) continue;

        // Category header
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.setTextColor(59, 130, 246);
        pdf.text(category, margin, y);
        y += 8;

        // Fields in this category
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        pdf.setTextColor(0, 0, 0);

        for (const [key, value] of fields) {
          if (y > 270) { // Check for page break
            pdf.addPage();
            y = margin;
          }
          
          pdf.setFont('helvetica', 'bold');
          pdf.text(`${key}:`, margin + 5, y);
          pdf.setFont('helvetica', 'normal');
          const keyWidth = pdf.getTextWidth(`${key}: `);
          pdf.text(String(value), margin + 5 + keyWidth, y);
          y += 6;
        }

        y += 5; // Space between categories
      }
    } else {
      // Simple list format
      Object.entries(metadata).forEach(([key, value]) => {
        if (value && y < 270) {
          pdf.setFont('helvetica', 'bold');
          pdf.text(`${key}:`, margin, y);
          pdf.setFont('helvetica', 'normal');
          const keyWidth = pdf.getTextWidth(`${key}: `);
          pdf.text(String(value), margin + keyWidth, y);
          y += 6;
        }
      });
    }

    return y + 10;
  }

  categorizeMetadata(metadata) {
    const categories = {
      'File Information': [],
      'Camera Information': [],
      'Camera Settings': [],
      'Date & Time': [],
      'Location Data': [],
      'Technical Details': []
    };

    const categoryMap = {
      fileName: 'File Information',
      fileSize: 'File Information',
      fileType: 'File Information',
      imageWidth: 'File Information',
      imageHeight: 'File Information',
      make: 'Camera Information',
      model: 'Camera Information',
      software: 'Camera Information',
      lens: 'Camera Information',
      fNumber: 'Camera Settings',
      exposureTime: 'Camera Settings',
      iso: 'Camera Settings',
      focalLength: 'Camera Settings',
      flash: 'Camera Settings',
      whiteBalance: 'Camera Settings',
      dateTime: 'Date & Time',
      dateTimeOriginal: 'Date & Time',
      dateTimeDigitized: 'Date & Time',
      gpsLatitude: 'Location Data',
      gpsLongitude: 'Location Data',
      gpsAltitude: 'Location Data',
      colorSpace: 'Technical Details',
      orientation: 'Technical Details',
      compression: 'Technical Details'
    };

    Object.entries(metadata).forEach(([key, value]) => {
      if (value) {
        const category = categoryMap[key] || 'Technical Details';
        categories[category].push([this.formatFieldName(key), this.formatFieldValue(key, value)]);
      }
    });

    return categories;
  }

  formatFieldName(key) {
    return key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
  }

  formatFieldValue(key, value) {
    switch (key) {
      case 'fileSize':
        return memoizedFormatters.fileSize(value);
      case 'dateTime':
      case 'dateTimeOriginal':
      case 'dateTimeDigitized':
        return memoizedFormatters.dateTime(value);
      case 'fNumber':
        return `f/${value}`;
      case 'exposureTime':
        return typeof value === 'number' && value < 1 ? `1/${Math.round(1/value)}s` : `${value}s`;
      case 'focalLength':
        return `${value}mm`;
      case 'iso':
        return `ISO ${value}`;
      default:
        return String(value);
    }
  }

  addFooter(pdf, options = {}) {
    const { pageWidth, pageHeight } = this.getPageDimensions(pdf);
    const totalPages = pdf.internal.getNumberOfPages();

    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      const footerY = pageHeight - 15;

      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.setTextColor(107, 114, 128);

      // Page number
      pdf.text(`Page ${i} of ${totalPages}`, 20, footerY);

      // Branding
      const brandText = options.certificationText || 'Generated by ProofPix - Privacy-Focused EXIF Analysis';
      const brandWidth = pdf.getTextWidth(brandText);
      pdf.text(brandText, pageWidth - 20 - brandWidth, footerY);

      // Timestamp
      if (options.style === 'professional') {
        pdf.text(`Report ID: RPT-${Date.now()}`, pageWidth / 2, footerY, { align: 'center' });
      }
    }
  }

  // Export methods
  async generatePdf(data, templateName = 'professional', options = {}) {
    const pdf = new jsPDF(options.orientation || 'portrait');
    
    if (!this.templates[templateName]) {
      throw new Error(`Template "${templateName}" not found`);
    }

    await this.templates[templateName].call(this, pdf, data, options);

    if (options.watermark) {
      this.addWatermark(pdf, options.watermarkOptions);
    }

    return pdf;
  }

  downloadPdf(pdf, filename) {
    const blob = pdf.output('blob');
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename.endsWith('.pdf') ? filename : `${filename}.pdf`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}

// Create singleton instance
export const enhancedPdfGenerator = new EnhancedPdfGenerator();

// React hook for enhanced PDF generation
export const useEnhancedPdfGenerator = () => {
  const [isGenerating, setIsGenerating] = React.useState(false);
  const [progress, setProgress] = React.useState(0);

  const generatePdf = React.useCallback(async (data, template = 'professional', options = {}) => {
    setIsGenerating(true);
    setProgress(0);

    try {
      setProgress(25);
      const pdf = await enhancedPdfGenerator.generatePdf(data, template, options);
      
      setProgress(75);
      const filename = options.filename || `proofpix-${template}-${Date.now()}.pdf`;
      
      setProgress(100);
      enhancedPdfGenerator.downloadPdf(pdf, filename);
      
      return filename;
    } catch (error) {
      console.error('Enhanced PDF generation failed:', error);
      throw error;
    } finally {
      setIsGenerating(false);
      setProgress(0);
    }
  }, []);

  const generateBatchPdf = React.useCallback(async (images, options = {}) => {
    setIsGenerating(true);
    setProgress(0);

    try {
      setProgress(25);
      const pdf = await enhancedPdfGenerator.generateBatchPdf(images, options);
      
      setProgress(75);
      const filename = options.filename || `proofpix-batch-${Date.now()}.pdf`;
      
      setProgress(100);
      enhancedPdfGenerator.downloadPdf(pdf, filename);
      
      return filename;
    } catch (error) {
      console.error('Batch PDF generation failed:', error);
      throw error;
    } finally {
      setIsGenerating(false);
      setProgress(0);
    }
  }, []);

  return {
    generatePdf,
    generateBatchPdf,
    isGenerating,
    progress
  };
}; 